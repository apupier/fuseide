<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>RabbitMQ Component</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="Red Hat Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Part&nbsp;V.&nbsp;Apache Camel Component Reference"><link rel="prev" href="quartz2-component.html" title="Quartz2 Component"><link rel="next" href="reactive-streams-component.html" title="Reactive Streams Component"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="rabbitmq-component"></a>RabbitMQ Component</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="rabbitmq-component.html#_uri_format_155">URI format</a></span></dt><dt><span class="section"><a href="rabbitmq-component.html#_options_119">Options</a></span></dt><dt><span class="section"><a href="rabbitmq-component.html#_using_connection_factory">Using connection factory</a></span></dt><dt><span class="section"><a href="rabbitmq-component.html#_message_headers_40">Message Headers</a></span></dt><dt><span class="section"><a href="rabbitmq-component.html#_message_body_23">Message Body</a></span></dt><dt><span class="section"><a href="rabbitmq-component.html#_samples_34">Samples</a></span></dt></dl></div><p><span class="strong"><strong>Available as of Camel version 2.12</strong></span></p><p>The <span class="strong"><strong>rabbitmq:</strong></span> component allows you produce and consume messages from
<a class="link" href="http://www.rabbitmq.com/" target="_top">RabbitMQ</a> instances. Using the RabbitMQ AMQP
client, this component offers a pure RabbitMQ approach over the generic
<a class="link" href="http://camel.apache.org/amqp.html" target="_top">AMQP</a> component.</p><p>Maven users will need to add the following dependency to their <code class="literal">pom.xml</code>
for this component:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-rabbitmq<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_uri_format_155"></a>URI format</h2></div></div></div><p>The old syntax is <span class="strong"><strong>deprecated</strong></span>:</p><pre class="programlisting">rabbitmq://hostname[:port]/exchangeName?[options]</pre><p>Instead the hostname and port is configured on the component level, or
can be provided as uri query parameters instead.</p><p>The new syntax is:</p><pre class="programlisting">rabbitmq:exchangeName?[options]</pre><p>Where <span class="strong"><strong>hostname</strong></span> is the hostname of the running rabbitmq instance or
cluster. Port is optional and if not specified then defaults to the
RabbitMQ client default (5672). The exchange name determines which
exchange produced messages will sent to. In the case of consumers, the
exchange name determines which exchange the queue will bind to.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_options_119"></a>Options</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="rabbitmq-component.html#_path_parameters_1_parameters_144">Path Parameters (1 parameters):</a></span></dt><dt><span class="section"><a href="rabbitmq-component.html#_query_parameters_60_parameters">Query Parameters (60 parameters):</a></span></dt></dl></div><p>The RabbitMQ component supports 48 options which are listed below.</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>hostname</strong></span> (common)</p></td><td align="left" valign="top"><p>The hostname of the running rabbitmq instance or cluster.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>portNumber</strong></span> (common)</p></td><td align="left" valign="top"><p>Port number for the host with the running rabbitmq instance or cluster.</p></td><td align="center" valign="top"><p>5672</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>username</strong></span> (security)</p></td><td align="left" valign="top"><p>Username in case of authenticated access</p></td><td align="center" valign="top"><p>guest</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>password</strong></span> (security)</p></td><td align="left" valign="top"><p>Password for authenticated access</p></td><td align="center" valign="top"><p>guest</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>vhost</strong></span> (common)</p></td><td align="left" valign="top"><p>The vhost for the channel</p></td><td align="center" valign="top"><p>/</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>addresses</strong></span> (common)</p></td><td align="left" valign="top"><p>If this option is set, camel-rabbitmq will try to create connection based on the setting of option addresses. The addresses value is a string which looks like server1:12345, server2:12345</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>connectionFactory</strong></span> (common)</p></td><td align="left" valign="top"><p>To use a custom RabbitMQ connection factory. When this option is set, all connection options (connectionTimeout, requestedChannelMax&#8230;&#8203;) set on URI are not used</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ConnectionFactory</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>threadPoolSize</strong></span> (consumer)</p></td><td align="left" valign="top"><p>The consumer uses a Thread Pool Executor with a fixed number of threads. This setting allows you to set that number of threads.</p></td><td align="center" valign="top"><p>10</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>autoDetectConnection Factory</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Whether to auto-detect looking up RabbitMQ connection factory from the registry. When enabled and a single instance of the connection factory is found then it will be used. An explicit connection factory can be configured on the component or endpoint level which takes precedence.</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>connectionTimeout</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection timeout</p></td><td align="center" valign="top"><p>60000</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestedChannelMax</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection requested channel max (max number of channels offered)</p></td><td align="center" valign="top"><p>0</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestedFrameMax</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection requested frame max (max size of frame offered)</p></td><td align="center" valign="top"><p>0</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestedHeartbeat</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection requested heartbeat (heart-beat in seconds offered)</p></td><td align="center" valign="top"><p>60</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>automaticRecovery Enabled</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Enables connection automatic recovery (uses connection implementation that performs automatic recovery when connection shutdown is not initiated by the application)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>networkRecoveryInterval</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Network recovery interval in milliseconds (interval used when recovering from network failure)</p></td><td align="center" valign="top"><p>5000</p></td><td align="left" valign="top"><p>Integer</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>topologyRecoveryEnabled</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Enables connection topology recovery (should topology recovery be performed)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchEnabled</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Enables the quality of service on the RabbitMQConsumer side. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchSize</strong></span> (consumer)</p></td><td align="left" valign="top"><p>The maximum amount of content (measured in octets) that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchCount</strong></span> (consumer)</p></td><td align="left" valign="top"><p>The maximum number of messages that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchGlobal</strong></span> (consumer)</p></td><td align="left" valign="top"><p>If the settings should be applied to the entire channel rather than each consumer You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>channelPoolMaxSize</strong></span> (producer)</p></td><td align="left" valign="top"><p>Get maximum number of opened channel in pool</p></td><td align="center" valign="top"><p>10</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>channelPoolMaxWait</strong></span> (producer)</p></td><td align="left" valign="top"><p>Set the maximum number of milliseconds to wait for a channel from the pool</p></td><td align="center" valign="top"><p>1000</p></td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestTimeout</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Set timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds)</p></td><td align="center" valign="top"><p>20000</p></td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestTimeoutChecker Interval</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Set requestTimeoutCheckerInterval for inOut exchange</p></td><td align="center" valign="top"><p>1000</p></td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>transferException</strong></span> (advanced)</p></td><td align="left" valign="top"><p>When true and an inOut Exchange failed on the consumer side send the caused Exception back in the response</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>publisher Acknowledgements</strong></span> (producer)</p></td><td align="left" valign="top"><p>When true, the message will be published with publisher acknowledgements turned on</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>publisher AcknowledgementsTimeout</strong></span> (producer)</p></td><td align="left" valign="top"><p>The amount of time in milliseconds to wait for a basic.ack response from RabbitMQ server</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>guaranteedDeliveries</strong></span> (producer)</p></td><td align="left" valign="top"><p>When true, an exception will be thrown when the message cannot be delivered (basic.return) and the message is marked as mandatory. PublisherAcknowledgement will also be activated in this case. See also publisher acknowledgements - When will messages be confirmed.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>mandatory</strong></span> (producer)</p></td><td align="left" valign="top"><p>This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set, the server will return an unroutable message with a Return method. If this flag is zero, the server silently drops the message. If the header is present rabbitmq.MANDATORY it will override this option.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>immediate</strong></span> (producer)</p></td><td align="left" valign="top"><p>This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is zero, the server will queue the message, but with no guarantee that it will ever be consumed. If the header is present rabbitmq.IMMEDIATE it will override this option.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>args</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each: Exchange: arg.exchange. Queue: arg.queue. Binding: arg.binding. For example to declare a queue with message ttl argument: <a class="link" href="http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000" target="_top">http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000</a></p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Map</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>clientProperties</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection client properties (client info used in negotiating with the server)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Map</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>sslProtocol</strong></span> (security)</p></td><td align="left" valign="top"><p>Enables SSL on connection, accepted value are true, TLS and 'SSLv3</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>trustManager</strong></span> (security)</p></td><td align="left" valign="top"><p>Configure SSL trust manager, SSL should be enabled for this option to be effective</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>TrustManager</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>autoAck</strong></span> (consumer)</p></td><td align="left" valign="top"><p>If messages should be auto acknowledged</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>autoDelete</strong></span> (common)</p></td><td align="left" valign="top"><p>If it is true, the exchange will be deleted when it is no longer in use</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>durable</strong></span> (common)</p></td><td align="left" valign="top"><p>If we are declaring a durable exchange (the exchange will survive a server restart)</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exclusive</strong></span> (common)</p></td><td align="left" valign="top"><p>Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>passive</strong></span> (common)</p></td><td align="left" valign="top"><p>Passive queues depend on the queue already to be available at RabbitMQ.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>skipQueueDeclare</strong></span> (common)</p></td><td align="left" valign="top"><p>If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>skipQueueBind</strong></span> (common)</p></td><td align="left" valign="top"><p>If true the queue will not be bound to the exchange after declaring it</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>skipExchangeDeclare</strong></span> (common)</p></td><td align="left" valign="top"><p>This can be used if we need to declare the queue but not the exchange</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>declare</strong></span> (common)</p></td><td align="left" valign="top"><p>If the option is true, camel declare the exchange and queue name and bind them together. If the option is false, camel won&#8217;t declare the exchange and queue name on the server.</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterExchange</strong></span> (common)</p></td><td align="left" valign="top"><p>The name of the dead letter exchange</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterQueue</strong></span> (common)</p></td><td align="left" valign="top"><p>The name of the dead letter queue</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterRoutingKey</strong></span> (common)</p></td><td align="left" valign="top"><p>The routing key for the dead letter exchange</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterExchangeType</strong></span> (common)</p></td><td align="left" valign="top"><p>The type of the dead letter exchange</p></td><td align="center" valign="top"><p>direct</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>resolveProperty Placeholders</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr></tbody></table></div><p>The RabbitMQ endpoint is configured using URI syntax:</p><pre class="screen">rabbitmq:exchangeName</pre><p>with the following path and query parameters:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_path_parameters_1_parameters_144"></a>Path Parameters (1 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangeName</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Required</strong></span> The exchange name determines which exchange produced messages will sent to. In the case of consumers, the exchange name determines which exchange the queue will bind to.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_query_parameters_60_parameters"></a>Query Parameters (60 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>addresses</strong></span> (common)</p></td><td align="left" valign="top"><p>If this option is set, camel-rabbitmq will try to create connection based on the setting of option addresses. The addresses value is a string which looks like server1:12345, server2:12345</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Address[]</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>autoDelete</strong></span> (common)</p></td><td align="left" valign="top"><p>If it is true, the exchange will be deleted when it is no longer in use</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>connectionFactory</strong></span> (common)</p></td><td align="left" valign="top"><p>To use a custom RabbitMQ connection factory. When this option is set, all connection options (connectionTimeout, requestedChannelMax&#8230;&#8203;) set on URI are not used</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ConnectionFactory</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterExchange</strong></span> (common)</p></td><td align="left" valign="top"><p>The name of the dead letter exchange</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterExchangeType</strong></span> (common)</p></td><td align="left" valign="top"><p>The type of the dead letter exchange</p></td><td align="center" valign="top"><p>direct</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterQueue</strong></span> (common)</p></td><td align="left" valign="top"><p>The name of the dead letter queue</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>deadLetterRoutingKey</strong></span> (common)</p></td><td align="left" valign="top"><p>The routing key for the dead letter exchange</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>declare</strong></span> (common)</p></td><td align="left" valign="top"><p>If the option is true, camel declare the exchange and queue name and bind them together. If the option is false, camel won&#8217;t declare the exchange and queue name on the server.</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>durable</strong></span> (common)</p></td><td align="left" valign="top"><p>If we are declaring a durable exchange (the exchange will survive a server restart)</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangeType</strong></span> (common)</p></td><td align="left" valign="top"><p>The exchange type such as direct or topic.</p></td><td align="center" valign="top"><p>direct</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exclusive</strong></span> (common)</p></td><td align="left" valign="top"><p>Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>hostname</strong></span> (common)</p></td><td align="left" valign="top"><p>The hostname of the running rabbitmq instance or cluster.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>passive</strong></span> (common)</p></td><td align="left" valign="top"><p>Passive queues depend on the queue already to be available at RabbitMQ.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>portNumber</strong></span> (common)</p></td><td align="left" valign="top"><p>Port number for the host with the running rabbitmq instance or cluster. Default value is 5672.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>queue</strong></span> (common)</p></td><td align="left" valign="top"><p>The queue to receive messages from</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>routingKey</strong></span> (common)</p></td><td align="left" valign="top"><p>The routing key to use when binding a consumer queue to the exchange. For producer routing keys, you set the header rabbitmq.ROUTING_KEY.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>skipExchangeDeclare</strong></span> (common)</p></td><td align="left" valign="top"><p>This can be used if we need to declare the queue but not the exchange</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>skipQueueBind</strong></span> (common)</p></td><td align="left" valign="top"><p>If true the queue will not be bound to the exchange after declaring it</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>skipQueueDeclare</strong></span> (common)</p></td><td align="left" valign="top"><p>If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>vhost</strong></span> (common)</p></td><td align="left" valign="top"><p>The vhost for the channel</p></td><td align="center" valign="top"><p>/</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>autoAck</strong></span> (consumer)</p></td><td align="left" valign="top"><p>If messages should be auto acknowledged</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>bridgeErrorHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>concurrentConsumers</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Number of concurrent consumers when consuming from broker. (eg similar as to the same option for the JMS component).</p></td><td align="center" valign="top"><p>1</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchCount</strong></span> (consumer)</p></td><td align="left" valign="top"><p>The maximum number of messages that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchEnabled</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Enables the quality of service on the RabbitMQConsumer side. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchGlobal</strong></span> (consumer)</p></td><td align="left" valign="top"><p>If the settings should be applied to the entire channel rather than each consumer You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>prefetchSize</strong></span> (consumer)</p></td><td align="left" valign="top"><p>The maximum amount of content (measured in octets) that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exceptionHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExceptionHandler</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangePattern</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Sets the exchange pattern when the consumer creates an exchange.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExchangePattern</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>threadPoolSize</strong></span> (consumer)</p></td><td align="left" valign="top"><p>The consumer uses a Thread Pool Executor with a fixed number of threads. This setting allows you to set that number of threads.</p></td><td align="center" valign="top"><p>10</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>bridgeEndpoint</strong></span> (producer)</p></td><td align="left" valign="top"><p>If the bridgeEndpoint is true, the producer will ignore the message header of rabbitmq.EXCHANGE_NAME and rabbitmq.ROUTING_KEY</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>channelPoolMaxSize</strong></span> (producer)</p></td><td align="left" valign="top"><p>Get maximum number of opened channel in pool</p></td><td align="center" valign="top"><p>10</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>channelPoolMaxWait</strong></span> (producer)</p></td><td align="left" valign="top"><p>Set the maximum number of milliseconds to wait for a channel from the pool</p></td><td align="center" valign="top"><p>1000</p></td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>guaranteedDeliveries</strong></span> (producer)</p></td><td align="left" valign="top"><p>When true, an exception will be thrown when the message cannot be delivered (basic.return) and the message is marked as mandatory. PublisherAcknowledgement will also be activated in this case. See also publisher acknowledgements - When will messages be confirmed.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>immediate</strong></span> (producer)</p></td><td align="left" valign="top"><p>This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is zero, the server will queue the message, but with no guarantee that it will ever be consumed. If the header is present rabbitmq.IMMEDIATE it will override this option.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>mandatory</strong></span> (producer)</p></td><td align="left" valign="top"><p>This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set, the server will return an unroutable message with a Return method. If this flag is zero, the server silently drops the message. If the header is present rabbitmq.MANDATORY it will override this option.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>publisherAcknowledgements</strong></span> (producer)</p></td><td align="left" valign="top"><p>When true, the message will be published with publisher acknowledgements turned on</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>publisherAcknowledgements Timeout</strong></span> (producer)</p></td><td align="left" valign="top"><p>The amount of time in milliseconds to wait for a basic.ack response from RabbitMQ server</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>args</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each: Exchange: arg.exchange. Queue: arg.queue. Binding: arg.binding. For example to declare a queue with message ttl argument: <a class="link" href="http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000" target="_top">http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000</a></p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Map</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>automaticRecoveryEnabled</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Enables connection automatic recovery (uses connection implementation that performs automatic recovery when connection shutdown is not initiated by the application)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>bindingArgs</strong></span> (advanced)</p></td><td align="left" valign="top"><p><span class="strong"><strong>Deprecated</strong></span> Key/value args for configuring the queue binding parameters when declare=true</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Map</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>clientProperties</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection client properties (client info used in negotiating with the server)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Map</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>connectionTimeout</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection timeout</p></td><td align="center" valign="top"><p>60000</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangeArgs</strong></span> (advanced)</p></td><td align="left" valign="top"><p><span class="strong"><strong>Deprecated</strong></span> Key/value args for configuring the exchange parameters when declare=true</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Map</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangeArgsConfigurer</strong></span> (advanced)</p></td><td align="left" valign="top"><p><span class="strong"><strong>Deprecated</strong></span> Set the configurer for setting the exchange args in Channel.exchangeDeclare</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ArgsConfigurer</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>networkRecoveryInterval</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Network recovery interval in milliseconds (interval used when recovering from network failure)</p></td><td align="center" valign="top"><p>5000</p></td><td align="left" valign="top"><p>Integer</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>queueArgs</strong></span> (advanced)</p></td><td align="left" valign="top"><p><span class="strong"><strong>Deprecated</strong></span> Key/value args for configuring the queue parameters when declare=true</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Map</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>queueArgsConfigurer</strong></span> (advanced)</p></td><td align="left" valign="top"><p><span class="strong"><strong>Deprecated</strong></span> Set the configurer for setting the queue args in Channel.queueDeclare</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ArgsConfigurer</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestedChannelMax</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection requested channel max (max number of channels offered)</p></td><td align="center" valign="top"><p>0</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestedFrameMax</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection requested frame max (max size of frame offered)</p></td><td align="center" valign="top"><p>0</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestedHeartbeat</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Connection requested heartbeat (heart-beat in seconds offered)</p></td><td align="center" valign="top"><p>60</p></td><td align="left" valign="top"><p>int</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestTimeout</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Set timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds)</p></td><td align="center" valign="top"><p>20000</p></td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>requestTimeoutChecker Interval</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Set requestTimeoutCheckerInterval for inOut exchange</p></td><td align="center" valign="top"><p>1000</p></td><td align="left" valign="top"><p>long</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>synchronous</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>topologyRecoveryEnabled</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Enables connection topology recovery (should topology recovery be performed)</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>transferException</strong></span> (advanced)</p></td><td align="left" valign="top"><p>When true and an inOut Exchange failed on the consumer side send the caused Exception back in the response</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>password</strong></span> (security)</p></td><td align="left" valign="top"><p>Password for authenticated access</p></td><td align="center" valign="top"><p>guest</p></td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>sslProtocol</strong></span> (security)</p></td><td align="left" valign="top"><p>Enables SSL on connection, accepted value are true, TLS and 'SSLv3</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>trustManager</strong></span> (security)</p></td><td align="left" valign="top"><p>Configure SSL trust manager, SSL should be enabled for this option to be effective</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>TrustManager</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>username</strong></span> (security)</p></td><td align="left" valign="top"><p>Username in case of authenticated access</p></td><td align="center" valign="top"><p>guest</p></td><td align="left" valign="top"><p>String</p></td></tr></tbody></table></div><p>See
<a class="link" href="http://www.rabbitmq.com/releases/rabbitmq-java-client/current-javadoc/com/rabbitmq/client/ConnectionFactory.html" target="_top">http://www.rabbitmq.com/releases/rabbitmq-java-client/current-javadoc/com/rabbitmq/client/ConnectionFactory.html</a>
and the AMQP specification for more information on connection options.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_using_connection_factory"></a>Using connection factory</h2></div></div></div><p>To connect to RabbitMQ you can setup a <code class="literal">ConnectionFactory</code> (same as with JMS) with the login details such as:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;bean</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">id</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"rabbitConnectionFactory"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">class</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"com.rabbitmq.client.ConnectionFactory"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;property</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">name</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"host"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">value</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"localhost"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;property</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">name</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"port"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">value</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"5672"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;property</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">name</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"username"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">value</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"camel"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;property</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">name</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"password"</span> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">value</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"bugsbunny"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/bean&gt;</strong>

And then refer to the connection factory in the endpoint uri as shown below:

<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;camelContext&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;route&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;from</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">uri</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"direct:rabbitMQEx2"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;to</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">uri</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"rabbitmq:ex2?connectionFactory=#rabbitConnectionFactory"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/route&gt;</strong>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/camelContext&gt;</strong></pre><p>From Camel 2.21 onwards the <code class="literal">ConnectionFactory</code> is auto-detected by default, so you can just do</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;camelContext&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;route&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;from</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">uri</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"direct:rabbitMQEx2"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;to</strong> <span xmlns="http://www.w3.org/1999/xhtml" class="hl-attribute" style="color: #F5844C">uri</span>=<span xmlns="http://www.w3.org/1999/xhtml" class="hl-value" style="color: #993300">"rabbitmq:ex2"</span><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">/&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/route&gt;</strong>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/camelContext&gt;</strong></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_message_headers_40"></a>Message Headers</h2></div></div></div><p>The following headers are set on exchanges when consuming messages.</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="90%" class="col_2"></colgroup><thead><tr><th align="left" valign="top">Property</th><th align="left" valign="top">Value</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.ROUTING_KEY</code></p></td><td align="left" valign="top"><p>The routing key that was used to receive the message, or the routing key
that will be used when producing a message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.EXCHANGE_NAME</code></p></td><td align="left" valign="top"><p>The exchange the message was received from</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.DELIVERY_TAG</code></p></td><td align="left" valign="top"><p>The rabbitmq delivery tag of the received message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.REDELIVERY_TAG</code></p></td><td align="left" valign="top"><p>Whether the message is a redelivered</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.REQUEUE</code></p></td><td align="left" valign="top"><p><span class="strong"><strong>Camel 2.14.2:</strong></span> This is used by the consumer to control rejection of the
message. When the consumer is complete processing the exchange, and if
the exchange failed, then the consumer is going to reject the message
from the RabbitMQ broker. The value of this header controls this
behavior. If the value is false (by default) then the message is
discarded/dead-lettered. If the value is true, then the message is
re-queued.&nbsp;</p></td></tr></tbody></table></div><p>The following headers are used by the producer. If these are set on the
camel exchange then they will be set on the RabbitMQ message.</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="90%" class="col_2"></colgroup><thead><tr><th align="left" valign="top">Property</th><th align="left" valign="top">Value</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.ROUTING_KEY</code></p></td><td align="left" valign="top"><p>The routing key that will be used when sending the message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.EXCHANGE_NAME</code></p></td><td align="left" valign="top"><p>The exchange the message was received from</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.EXCHANGE_OVERRIDE_NAME</code></p></td><td align="left" valign="top"><p><span class="strong"><strong>Camel 2.21:</strong></span> Used for force sending the message to this exchange instead of the endpoint configured name on the producer</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.CONTENT_TYPE</code></p></td><td align="left" valign="top"><p>The contentType to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.PRIORITY</code></p></td><td align="left" valign="top"><p>The priority header to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.CORRELATIONID</code></p></td><td align="left" valign="top"><p>The correlationId to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.MESSAGE_ID</code></p></td><td align="left" valign="top"><p>The message id to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.DELIVERY_MODE</code></p></td><td align="left" valign="top"><p>If the message should be persistent or not</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.USERID</code></p></td><td align="left" valign="top"><p>The userId to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.CLUSTERID</code></p></td><td align="left" valign="top"><p>The clusterId to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.REPLY_TO</code></p></td><td align="left" valign="top"><p>The replyTo to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.CONTENT_ENCODING</code></p></td><td align="left" valign="top"><p>The contentEncoding to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.TYPE</code></p></td><td align="left" valign="top"><p>The type to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.EXPIRATION</code></p></td><td align="left" valign="top"><p>The expiration to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.TIMESTAMP</code></p></td><td align="left" valign="top"><p>The timestamp to set on the RabbitMQ message</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">rabbitmq.APP_ID</code></p></td><td align="left" valign="top"><p>The appId to set on the RabbitMQ message</p></td></tr></tbody></table></div><p>Headers are set by the consumer once the message is received. The
producer will also set the headers for downstream processors once the
exchange has taken place. Any headers set prior to production that the
producer sets will be overriden.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_message_body_23"></a>Message Body</h2></div></div></div><p>The component will use the camel exchange in body as the rabbit mq
message body. The camel exchange in object must be convertible to a byte
array. Otherwise the producer will throw an exception of unsupported
body type.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_samples_34"></a>Samples</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="rabbitmq-component.html#_issue_when_routing_between_exchanges_in_camel_2_20_x_or_older">Issue when routing between exchanges (in Camel 2.20.x or older)</a></span></dt></dl></div><p>To receive messages from a queue that is bound to an exchange A with the
routing key B,</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:A?routingKey=B"</em></strong>)</pre><p>To receive messages from a queue with a single thread with auto
acknowledge disabled.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:A?routingKey=B&amp;threadPoolSize=1&amp;autoAck=false"</em></strong>)</pre><p>To send messages to an exchange called C</p><pre class="programlisting">to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:C"</em></strong>)</pre><p>Declaring a headers exchange and queue</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:ex?exchangeType=headers&amp;queue=q&amp;bindingArgs=#bindArgs"</em></strong>)</pre><p>and place corresponding <code class="literal">Map&lt;String, Object&gt;</code> with the id of "bindArgs" in the Registry.</p><p>For example declaring a method in spring</p><pre class="programlisting"><em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@Bean(name="bindArgs")</span></em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> Map&lt;String, Object&gt; bindArgsBuilder() {
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">return</strong> Collections.singletonMap(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"foo"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"bar"</em></strong>);
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_issue_when_routing_between_exchanges_in_camel_2_20_x_or_older"></a>Issue when routing between exchanges (in Camel 2.20.x or older)</h3></div></div></div><p>If you for example want to route messages from one Rabbit exchange to another as shown
in the example below with foo &#8594; bar:</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:foo"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:bar"</em></strong>)</pre><p>Then beware that Camel will route the message to itself, eg foo &#8594; foo. So why is that?
This is because the consumer that receives the message (eg from) provides the message header
<code class="literal">rabbitmq.EXCHANGE_NAME</code> with the name of the exchange, eg <code class="literal">foo</code>. And when the Camel producer
is sending the message to <code class="literal">bar</code> then the header <code class="literal">rabbitmq.EXCHANGE_NAME</code> will override this
and instead send the message to <code class="literal">foo</code>.</p><p>To avoid this you need to either:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Remove the header:</li></ul></div><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:foo"</em></strong>)
  .removeHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq.EXCHANGE_NAME"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:bar"</em></strong>)</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Or turn on <code class="literal">bridgeEndpoint</code> mode on the producer:</li></ul></div><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:foo"</em></strong>)
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:bar?bridgeEndpoint=true"</em></strong>)</pre><p>From Camel 2.21 onwards this has been improved so you can easily route between exchanges.
The header <code class="literal">rabbitmq.EXCHANGE_NAME</code> is not longer used by the producer to override the destination exchange.
Instead a new header <code class="literal">rabbitmq.EXCHANGE_OVERRIDE_NAME</code> can be used to send to a different exchange.
For example to send to cheese exchange you can do</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:foo"</em></strong>)
  .setHeader(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq.EXCHANGE_OVERRIDE_NAME"</em></strong>, constant(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"cheese"</em></strong>))
  .to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"rabbitmq:bar"</em></strong>)</pre></div></div></div></body></html>