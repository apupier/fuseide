<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Guava EventBus Component</title><link rel="stylesheet" type="text/css" href="eclipse_book.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="Red Hat Fuse Tooling for Eclipse"><link rel="up" href="IDU-Components.html" title="Part&nbsp;V.&nbsp;Apache Camel Component Reference"><link rel="prev" href="grpc-component.html" title="gRPC Component"><link rel="next" href="_hazelcast_component.html" title="Hazelcast Component"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="guava-eventbus-component"></a>Guava EventBus Component</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="guava-eventbus-component.html#_uri_format_87">URI format</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#_options_48">Options</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#_usage_82">Usage</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#_deadevent_considerations">DeadEvent considerations</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#_consuming_multiple_type_of_events">Consuming multiple type of events</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-HawtDB">HawtDB</a></span></dt></dl></div><p><span class="strong"><strong>Available as of Camel version 2.10</strong></span></p><p>The
<a class="link" href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/eventbus/package-summary.html" target="_top">Google
Guava EventBus</a> allows publish-subscribe-style communication between
components without requiring the components to explicitly register with
one another (and thus be aware of each other). The <span class="strong"><strong>guava-eventbus:</strong></span>
component provides integration bridge between Camel and
<a class="link" href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/eventbus/package-summary.html" target="_top">Google
Guava EventBus</a> infrastructure. With the latter component, messages
exchanged with the Guava <code class="literal">EventBus</code> can be transparently forwarded to
the Camel routes. EventBus component allows also to route body of Camel
exchanges to the Guava <code class="literal">EventBus</code>.</p><p>Maven users will need to add the following dependency to their <code class="literal">pom.xml</code>
for this component:</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-guava-eventbus<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>x.x.x<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
    <em xmlns="http://www.w3.org/1999/xhtml" class="hl-comment" style="color: silver">&lt;!-- use the same version as your Camel core version --&gt;</em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_uri_format_87"></a>URI format</h2></div></div></div><pre class="programlisting">guava-eventbus:busName[?options]</pre><p>Where <span class="strong"><strong>busName</strong></span> represents the name of the
<code class="literal">com.google.common.eventbus.EventBus</code> instance located in the Camel
registry.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_options_48"></a>Options</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="guava-eventbus-component.html#_path_parameters_1_parameters_66">Path Parameters (1 parameters):</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#_query_parameters_6_parameters_4">Query Parameters (6 parameters):</a></span></dt></dl></div><p>The Guava EventBus component supports 3 options which are listed below.</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>eventBus</strong></span> (common)</p></td><td align="left" valign="top"><p>To use the given Guava EventBus instance</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>EventBus</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>listenerInterface</strong></span> (common)</p></td><td align="left" valign="top"><p>The interface with method(s) marked with the Subscribe annotation. Dynamic proxy will be created over the interface so it could be registered as the EventBus listener. Particularly useful when creating multi-event listeners and for handling DeadEvent properly. This option cannot be used together with eventClass option.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Class&lt;?&gt;</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>resolveProperty Placeholders</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders.</p></td><td align="center" valign="top"><p>true</p></td><td align="left" valign="top"><p>boolean</p></td></tr></tbody></table></div><p>The Guava EventBus endpoint is configured using URI syntax:</p><pre class="screen">guava-eventbus:eventBusRef</pre><p>with the following path and query parameters:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_path_parameters_1_parameters_66"></a>Path Parameters (1 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>eventBusRef</strong></span></p></td><td align="left" valign="top"><p>To lookup the Guava EventBus from the registry with the given name</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>String</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_query_parameters_6_parameters_4"></a>Query Parameters (6 parameters):</h3></div></div></div><div class="informaltable"><table border="1" width="100%"><colgroup><col width="19%" class="col_1"><col width="51%" class="col_2"><col width="10%" class="col_3"><col width="20%" class="col_4"></colgroup><thead><tr><th align="left" valign="top">Name</th><th align="left" valign="top">Description</th><th align="center" valign="top">Default</th><th align="left" valign="top">Type</th></tr></thead><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>eventClass</strong></span> (common)</p></td><td align="left" valign="top"><p>If used on the consumer side of the route, will filter events received from the EventBus to the instances of the class and superclasses of eventClass. Null value of this option is equal to setting it to the java.lang.Object i.e. the consumer will capture all messages incoming to the event bus. This option cannot be used together with listenerInterface option.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Class&lt;?&gt;</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>listenerInterface</strong></span> (common)</p></td><td align="left" valign="top"><p>The interface with method(s) marked with the Subscribe annotation. Dynamic proxy will be created over the interface so it could be registered as the EventBus listener. Particularly useful when creating multi-event listeners and for handling DeadEvent properly. This option cannot be used together with eventClass option.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>Class&lt;?&gt;</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>bridgeErrorHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exceptionHandler</strong></span> (consumer)</p></td><td align="left" valign="top"><p>To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this options is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExceptionHandler</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>exchangePattern</strong></span> (consumer)</p></td><td align="left" valign="top"><p>Sets the exchange pattern when the consumer creates an exchange.</p></td><td align="center" valign="top">&nbsp;</td><td align="left" valign="top"><p>ExchangePattern</p></td></tr><tr><td align="left" valign="top"><p><span class="strong"><strong>synchronous</strong></span> (advanced)</p></td><td align="left" valign="top"><p>Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).</p></td><td align="center" valign="top"><p>false</p></td><td align="left" valign="top"><p>boolean</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_usage_82"></a>Usage</h2></div></div></div><p>Using <code class="literal">guava-eventbus</code> component on the consumer side of the route will
capture messages sent to the Guava <code class="literal">EventBus</code> and forward them to the
Camel route. Guava EventBus consumer processes incoming messages
<a class="link" href="http://camel.apache.org/asynchronous-routing-engine.html" target="_top">asynchronously</a>.</p><pre class="programlisting">SimpleRegistry registry = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> SimpleRegistry();
EventBus eventBus = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> EventBus();
registry.put(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"busName"</em></strong>, eventBus);
CamelContext camel = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> DefaultCamelContext(registry);

from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"guava-eventbus:busName"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"seda:queue"</em></strong>);

eventBus.post(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Send me to the SEDA queue."</em></strong>);</pre><p>Using <code class="literal">guava-eventbus</code> component on the producer side of the route will
forward body of the Camel exchanges to the Guava <code class="literal">EventBus</code> instance.</p><pre class="programlisting">SimpleRegistry registry = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> SimpleRegistry();
EventBus eventBus = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> EventBus();
registry.put(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"busName"</em></strong>, eventBus);
CamelContext camel = <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> DefaultCamelContext(registry);

from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"guava-eventbus:busName"</em></strong>);

ProducerTemplate producerTemplate = camel.createProducerTemplate();
producer.sendBody(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"direct:start"</em></strong>, <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Send me to the Guava EventBus."</em></strong>);

eventBus.register(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">new</strong> Object(){
  <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@Subscribe</span></em>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> messageHander(String message) {
    System.out.println(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"Message received from the Camel: "</em></strong> + message);
  }
});</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_deadevent_considerations"></a>DeadEvent considerations</h2></div></div></div><p>Keep in mind that due to the limitations caused by the design of the
Guava EventBus, you cannot specify event class to be received by the
listener without creating class annotated with <code class="literal">@Subscribe</code> method. This
limitation implies that endpoint with <code class="literal">eventClass</code> option specified
actually listens to all possible events (<code class="literal">java.lang.Object</code>) and filter
appropriate messages programmatically at runtime. The snipped below
demonstrates an appropriate excerpt from the Camel code base.</p><pre class="programlisting"><em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@Subscribe</span></em>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> eventReceived(Object event) {
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">if</strong> (eventClass == null || eventClass.isAssignableFrom(event.getClass())) {
    doEventReceived(event);
...</pre><p>This drawback of this approach is that <code class="literal">EventBus</code> instance used by Camel
will never generate <code class="literal">com.google.common.eventbus.DeadEvent</code>
notifications. If you want Camel to listen only to the precisely
specified event (and therefore enable <code class="literal">DeadEvent</code> support), use
<code class="literal">listenerInterface</code> endpoint option. Camel will create dynamic proxy
over the interface you specify with the latter option and listen only to
messages specified by the interface handler methods. The example of the
listener interface with single method handling only <code class="literal">SpecificEvent</code>
instances is demonstrated below.</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">package</strong> com.example;

<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">interface</strong> CustomListener {

  <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@Subscribe</span></em>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> eventReceived(SpecificEvent event);

}</pre><p>The listener presented above could be used in the endpoint definition as
follows.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"guava-eventbus:busName?listenerInterface=com.example.CustomListener"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"seda:queue"</em></strong>);</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_consuming_multiple_type_of_events"></a>Consuming multiple type of events</h2></div></div></div><p>In order to define multiple type of events to be consumed by Guava
EventBus consumer use <code class="literal">listenerInterface</code> endpoint option, as listener
interface could provide multiple methods marked with the <code class="literal">@Subscribe</code>
annotation.</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">package</strong> com.example;

<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">public</strong> <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">interface</strong> MultipleEventsListener {

  <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@Subscribe</span></em>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> someEventReceived(SomeEvent event);

  <em xmlns="http://www.w3.org/1999/xhtml"><span class="hl-annotation" style="color: gray">@Subscribe</span></em>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-keyword">void</strong> anotherEventReceived(AnotherEvent event);

}</pre><p>The listener presented above could be used in the endpoint definition as
follows.</p><pre class="programlisting">from(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"guava-eventbus:busName?listenerInterface=com.example.MultipleEventsListener"</em></strong>).to(<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-string"><em style="color:red">"seda:queue"</em></strong>);</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="HawtDB-HawtDB"></a>HawtDB</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-UsingHawtDBAggregationRepository">Using HawtDBAggregationRepository</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-Whatispreservedwhenpersisting">What is preserved when persisting</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-Recovery">Recovery</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-Dependencies">Dependencies</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-SeeAlso">See Also</a></span></dt></dl></div><p><span class="strong"><strong>Available as of Camel 2.3</strong></span></p><p><a class="link" href="http://hawtdb.fusesource.org/" target="_top">HawtDB</a> is a very lightweight and
embedable key value database. It allows together with Camel to provide
persistent support for various Camel features such as
Aggregator.</p><p><span class="strong"><strong>Deprecated</strong></span></p><p>The <a class="link" href="http://hawtdb.fusesource.org/" target="_top">HawtDB</a> project is being deprecated
and replaced by <a class="link" href="https://code.google.com/p/leveldb/" target="_top">leveldb</a> as the
lightweight and embedable key value database. To make using leveldb easy
there is a <a class="link" href="https://github.com/fusesource/leveldbjni" target="_top">leveldbjni</a> project
for that. The Apache ActiveMQ project is planning on using leveldb as
their primary file based message store in the future, to replace kahadb.</p><p>There os a camel-leveldb component we recommend to
use instead of this.</p><p><span class="strong"><strong>Issue with HawtDB 1.4 or older</strong></span></p><p>There is a bug in HawtDB 1.4 or older which means the filestore will not
free unused space. That means the file keeps growing. This has been
fixed in HawtDB 1.5 which is shipped with Camel 2.5 onwards.</p><p>Current features it provides:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">HawtDBAggregationRepository</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="HawtDB-UsingHawtDBAggregationRepository"></a>Using HawtDBAggregationRepository</h3></div></div></div><p><code class="literal">HawtDBAggregationRepository</code> is an <code class="literal">AggregationRepository</code> which on the
fly persists the aggregated messages. This ensures that you will not
loose messages, as the default aggregator will use an in memory only
<code class="literal">AggregationRepository</code>.</p><p>It has the following options:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Option</th><th align="left" valign="top">Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">repositoryName</code></p></td><td align="left" valign="top"><p>String</p></td><td align="left" valign="top"><p>A mandatory repository name. Allows you to use a shared <code class="literal">HawtDBFile</code> for
multiple repositories.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">persistentFileName</code></p></td><td align="left" valign="top"><p>String</p></td><td align="left" valign="top"><p>Filename for the persistent storage. If no file exists on startup a new
file is created.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">bufferSize</code></p></td><td align="left" valign="top"><p>int</p></td><td align="left" valign="top"><p>The size of the memory segment buffer which is mapped to the file store.
By default its 8mb. The value is in bytes.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">sync</code></p></td><td align="left" valign="top"><p>boolean</p></td><td align="left" valign="top"><p>Whether or not the <code class="literal">HawtDBFile</code> should sync on write or not. Default is
<code class="literal">true</code>. By sync on write ensures that its always waiting for all writes
to be spooled to disk and thus will not loose updates. If you disable
this option, then HawtDB will auto sync when it has batched up a number
of writes.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">pageSize</code></p></td><td align="left" valign="top"><p>short</p></td><td align="left" valign="top"><p>The size of memory pages. By default its 512 bytes. The value is in
bytes.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">hawtDBFile</code></p></td><td align="left" valign="top"><p>HawtDBFile</p></td><td align="left" valign="top"><p>Use an existing configured
<code class="literal">org.apache.camel.component.hawtdb.HawtDBFile</code> instance.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">returnOldExchange</code></p></td><td align="left" valign="top"><p>boolean</p></td><td align="left" valign="top"><p>Whether the get operation should return the old existing Exchange if any
existed. By default this option is <code class="literal">false</code> to optimize as we do not need
the old exchange when aggregating.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">useRecovery</code></p></td><td align="left" valign="top"><p>boolean</p></td><td align="left" valign="top"><p>Whether or not recovery is enabled. This option is by default <code class="literal">true</code>.
When enabled the Camel Aggregator automatic
recover failed aggregated exchange and have them resubmitted.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">recoveryInterval</code></p></td><td align="left" valign="top"><p>long</p></td><td align="left" valign="top"><p>If recovery is enabled then a background task is run every x&#8217;th time to
scan for failed exchanges to recover and resubmit. By default this
interval is 5000 millis.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">maximumRedeliveries</code></p></td><td align="left" valign="top"><p>int</p></td><td align="left" valign="top"><p>Allows you to limit the maximum number of redelivery attempts for a
recovered exchange. If enabled then the Exchange will be moved to the
dead letter channel if all redelivery attempts failed. By default this
option is disabled. If this option is used then the <code class="literal">deadLetterUri</code>
option must also be provided.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">deadLetterUri</code></p></td><td align="left" valign="top"><p>String</p></td><td align="left" valign="top"><p>An endpoint uri for a Dead Letter Channel
where exhausted recovered Exchanges will be moved. If this option is
used then the <code class="literal">maximumRedeliveries</code> option must also be provided.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">optimisticLocking</code></p></td><td align="left" valign="top"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p><span class="strong"><strong>Camel 2.12:</strong></span> To turn on optimistic locking, which often would be needed
in clustered environments where multiple Camel applications shared the
same HawtDB based aggregation repository.</p></td></tr></tbody></table></div><p>The <code class="literal">repositoryName</code> option must be provided. Then either the
<code class="literal">persistentFileName</code> or the <code class="literal">hawtDBFile</code> must be provided.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="HawtDB-Whatispreservedwhenpersisting"></a>What is preserved when persisting</h3></div></div></div><p><code class="literal">HawtDBAggregationRepository</code> will only preserve any <code class="literal">Serializable</code>
compatible data types. If a data type is not such a type its dropped and
a <code class="literal">WARN</code> is logged. And it only persists the <code class="literal">Message</code> body and the
<code class="literal">Message</code> headers. The <code class="literal">Exchange</code> properties are <span class="strong"><strong>not</strong></span> persisted.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="HawtDB-Recovery"></a>Recovery</h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-UsingHawtDBAggregationRepositoryinJavaDSL">Using HawtDBAggregationRepository in Java DSL</a></span></dt><dt><span class="section"><a href="guava-eventbus-component.html#HawtDB-UsingHawtDBAggregationRepositoryinSpringXML">Using HawtDBAggregationRepository in Spring XML</a></span></dt></dl></div><p>The <code class="literal">HawtDBAggregationRepository</code> will by default recover any failed
Exchange. It does this by having a background tasks
that scans for failed Exchanges in the persistent
store. You can use the <code class="literal">checkInterval</code> option to set how often this task
runs. The recovery works as transactional which ensures that Camel will
try to recover and redeliver the failed Exchange.
Any Exchange which was found to be recovered will be
restored from the persistent store and resubmitted and send out again.</p><p>The following headers is set when an Exchange is
being recovered/redelivered:</p><div class="informaltable"><table border="1" width="100%"><colgroup><col width="10%" class="col_1"><col width="10%" class="col_2"><col width="80%" class="col_3"></colgroup><thead><tr><th align="left" valign="top">Header</th><th align="left" valign="top">Type</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">Exchange.REDELIVERED</code></p></td><td align="left" valign="top"><p>Boolean</p></td><td align="left" valign="top"><p>Is set to true to indicate the Exchange is being
redelivered.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">Exchange.REDELIVERY_COUNTER</code></p></td><td align="left" valign="top"><p>Integer</p></td><td align="left" valign="top"><p>The redelivery attempt, starting from 1.</p></td></tr></tbody></table></div><p>Only when an Exchange has been successfully
processed it will be marked as complete which happens when the <code class="literal">confirm</code>
method is invoked on the <code class="literal">AggregationRepository</code>. This means if the same
Exchange fails again it will be kept retried until
it success.</p><p>You can use option <code class="literal">maximumRedeliveries</code> to limit the maximum number of
redelivery attempts for a given recovered Exchange.
You must also set the <code class="literal">deadLetterUri</code> option so Camel knows where to
send the Exchange when the <code class="literal">maximumRedeliveries</code> was
hit.</p><p>You can see some examples in the unit tests of camel-hawtdb, for example
<a class="link" href="https://svn.apache.org/repos/asf/camel/trunk/components/camel-hawtdb/src/test/java/org/apache/camel/component/hawtdb/HawtDBAggregateRecoverTest.java" target="_top">this
test</a>.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="HawtDB-UsingHawtDBAggregationRepositoryinJavaDSL"></a>Using HawtDBAggregationRepository in Java DSL</h4></div></div></div><p>In this example we want to persist aggregated messages in the
<code class="literal">target/data/hawtdb.dat</code> file.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="HawtDB-UsingHawtDBAggregationRepositoryinSpringXML"></a>Using HawtDBAggregationRepository in Spring XML</h4></div></div></div><p>The same example but using Spring XML instead:</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="HawtDB-Dependencies"></a>Dependencies</h3></div></div></div><p>To use HawtDB in your camel routes you need to add the
a dependency on <span class="strong"><strong>camel-hawtdb</strong></span>.</p><p>If you use maven you could just add the following to your pom.xml,
substituting the version number for the latest &amp; greatest release (see
the download page for the latest versions).</p><pre class="programlisting"><strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.apache.camel<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>camel-hawtdb<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
  <strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;version&gt;</strong>2.3.0<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong xmlns="http://www.w3.org/1999/xhtml" class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="HawtDB-SeeAlso"></a>See Also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Configuring Camel</li><li class="listitem">Component</li><li class="listitem">Endpoint</li><li class="listitem">Getting Started</li><li class="listitem">Aggregator</li><li class="listitem">Components</li></ul></div></div></div></div></body></html>